# Production Profile Configuration
# All sensitive values are injected via environment variables from Kubernetes secrets

spring:
  # Database Configuration - Injected by infrastructure
  datasource:
    url: ${DATABASE_URL}  # Format: jdbc:postgresql://host:port/database
    username: ${DATABASE_USER}
    password: ${DATABASE_PASSWORD}
    driver-class-name: org.postgresql.Driver
    hikari:
      pool-name: IdentityServiceHikariCP
      maximum-pool-size: ${DB_POOL_MAX_SIZE:20}
      minimum-idle: ${DB_POOL_MIN_IDLE:10}
      connection-timeout: ${DB_CONNECTION_TIMEOUT:30000}
      idle-timeout: ${DB_IDLE_TIMEOUT:600000}
      max-lifetime: ${DB_MAX_LIFETIME:1800000}
      leak-detection-threshold: ${DB_LEAK_DETECTION:60000}
  
  jpa:
    hibernate:
      ddl-auto: validate # Never auto-create in production
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: false
        show_sql: false
        jdbc:
          batch_size: 50
          batch_versioned_data: true
        order_inserts: true
        order_updates: true
        connection:
          provider_disables_autocommit: true
    show-sql: false
    open-in-view: false
  
  # Liquibase - Database migrations
  liquibase:
    enabled: true
    change-log: classpath:db/changelog/db.changelog-master.xml
    contexts: production
    default-schema: ${DATABASE_SCHEMA:public}
    liquibase-schema: ${LIQUIBASE_SCHEMA:public}
  
  # Redis Configuration - Injected by infrastructure
  data:
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD}
      database: ${REDIS_DATABASE:0}
      timeout: ${REDIS_TIMEOUT:2000ms}
      connect-timeout: ${REDIS_CONNECT_TIMEOUT:10s}
      ssl:
        enabled: ${REDIS_SSL_ENABLED:true}
      lettuce:
        pool:
          enabled: true
          max-active: ${REDIS_POOL_MAX_ACTIVE:8}
          max-idle: ${REDIS_POOL_MAX_IDLE:8}
          min-idle: ${REDIS_POOL_MIN_IDLE:0}
          max-wait: ${REDIS_POOL_MAX_WAIT:-1ms}
        cluster:
          refresh:
            adaptive: true
            period: ${REDIS_CLUSTER_REFRESH_PERIOD:60s}
  
  # Kafka Configuration - Injected by infrastructure
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS}
    properties:
      security.protocol: ${KAFKA_SECURITY_PROTOCOL:SASL_SSL}
      sasl.mechanism: ${KAFKA_SASL_MECHANISM:PLAIN}
      sasl.jaas.config: org.apache.kafka.common.security.plain.PlainLoginModule required username="${KAFKA_USERNAME}" password="${KAFKA_PASSWORD}";
      ssl.endpoint.identification.algorithm: https
      session.timeout.ms: ${KAFKA_SESSION_TIMEOUT:30000}
      request.timeout.ms: ${KAFKA_REQUEST_TIMEOUT:30000}
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
      acks: all
      retries: ${KAFKA_PRODUCER_RETRIES:3}
      batch-size: ${KAFKA_PRODUCER_BATCH_SIZE:16384}
      linger-ms: ${KAFKA_PRODUCER_LINGER_MS:0}
      buffer-memory: ${KAFKA_PRODUCER_BUFFER_MEMORY:33554432}
      compression-type: ${KAFKA_COMPRESSION_TYPE:snappy}
      properties:
        enable.idempotence: true
        max.in.flight.requests.per.connection: 5
    consumer:
      group-id: ${KAFKA_CONSUMER_GROUP_ID:${spring.application.name}}
      auto-offset-reset: ${KAFKA_AUTO_OFFSET_RESET:earliest}
      enable-auto-commit: false
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: ${KAFKA_TRUSTED_PACKAGES:com.healthcare.identity}
        session.timeout.ms: ${KAFKA_SESSION_TIMEOUT:30000}
        max.poll.records: ${KAFKA_MAX_POLL_RECORDS:500}
    listener:
      ack-mode: manual
      concurrency: ${KAFKA_LISTENER_CONCURRENCY:3}
    admin:
      fail-fast: true
      properties:
        retry.backoff.ms: ${KAFKA_ADMIN_RETRY_BACKOFF:100}
        request.timeout.ms: ${KAFKA_ADMIN_REQUEST_TIMEOUT:30000}
  
  # Security Configuration
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${JWT_ISSUER_URI:https://${AUTH0_DOMAIN}/}
          jwk-set-uri: ${JWT_JWK_SET_URI:https://${AUTH0_DOMAIN}/.well-known/jwks.json}

# Auth0 Configuration - Production
auth0:
  domain: ${AUTH0_DOMAIN}
  clientId: ${AUTH0_CLIENT_ID}
  clientSecret: ${AUTH0_CLIENT_SECRET}
  audience: ${AUTH0_AUDIENCE}
  connection: ${AUTH0_CONNECTION:Username-Password-Authentication}
  scope: ${AUTH0_SCOPE:openid profile email}
  enabled: true
  cache:
    enabled: true
    ttl: ${AUTH0_CACHE_TTL:3600}

# FHIR Configuration - Production
fhir:
  server:
    url: ${FHIR_SERVER_URL}
    username: ${FHIR_USERNAME:}
    password: ${FHIR_PASSWORD:}
    timeout: ${FHIR_TIMEOUT:30000}
    max-connections: ${FHIR_MAX_CONNECTIONS:20}
    enabled: ${FHIR_ENABLED:true}
  version: ${FHIR_VERSION:R4}

# External Service URLs
external:
  services:
    kyc:
      url: ${KYC_SERVICE_URL:}
      api-key: ${KYC_API_KEY:}
      enabled: ${KYC_ENABLED:false}
    notification:
      url: ${NOTIFICATION_SERVICE_URL:}
      api-key: ${NOTIFICATION_API_KEY:}
      enabled: ${NOTIFICATION_ENABLED:true}

# Cloud Provider Specific
cloud:
  provider: ${CLOUD_PROVIDER:azure} # azure, aws, gcp
  region: ${CLOUD_REGION:eastus}
  
  # Azure specific
  azure:
    key-vault:
      enabled: ${AZURE_KEYVAULT_ENABLED:false}
      uri: ${AZURE_KEYVAULT_URI:}
      client-id: ${AZURE_CLIENT_ID:}
      client-secret: ${AZURE_CLIENT_SECRET:}
      tenant-id: ${AZURE_TENANT_ID:}
  
  # AWS specific
  aws:
    secrets-manager:
      enabled: ${AWS_SECRETS_ENABLED:false}
      region: ${AWS_SECRETS_REGION:us-east-1}
      prefix: ${AWS_SECRETS_PREFIX:identity-service}

# Monitoring & Observability
monitoring:
  metrics:
    export:
      prometheus:
        enabled: true
        endpoint: /metrics
  tracing:
    enabled: ${TRACING_ENABLED:true}
    sampling-rate: ${TRACING_SAMPLING_RATE:0.1}
    endpoint: ${TRACING_ENDPOINT:http://jaeger:14268/api/traces}
  
# CloudWatch Logging (if on AWS)
logging:
  cloudwatch:
    enabled: ${CLOUDWATCH_ENABLED:false}
    region: ${AWS_REGION:us-east-1}
    log-group: ${CLOUDWATCH_LOG_GROUP:/aws/ecs/identity-service}
    log-stream-prefix: ${HOSTNAME:identity}

# Production Security Settings
server:
  port: ${SERVER_PORT:8080}
  ssl:
    enabled: ${SSL_ENABLED:false}
    key-store: ${SSL_KEYSTORE:}
    key-store-password: ${SSL_KEYSTORE_PASSWORD:}
    key-store-type: ${SSL_KEYSTORE_TYPE:PKCS12}
    key-alias: ${SSL_KEY_ALIAS:}
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json
    min-response-size: 1024
  http2:
    enabled: ${HTTP2_ENABLED:true}
  forward-headers-strategy: ${FORWARD_HEADERS_STRATEGY:native}

# Resilience
resilience4j:
  circuitbreaker:
    instances:
      auth0:
        sliding-window-size: ${CB_WINDOW_SIZE:100}
        failure-rate-threshold: ${CB_FAILURE_THRESHOLD:50}
        wait-duration-in-open-state: ${CB_WAIT_DURATION:60s}
        permitted-number-of-calls-in-half-open-state: ${CB_HALF_OPEN_CALLS:10}
      fhir:
        sliding-window-size: ${CB_WINDOW_SIZE:100}
        failure-rate-threshold: ${CB_FAILURE_THRESHOLD:50}
        wait-duration-in-open-state: ${CB_WAIT_DURATION:60s}
  retry:
    instances:
      auth0:
        max-attempts: ${RETRY_MAX_ATTEMPTS:3}
        wait-duration: ${RETRY_WAIT_DURATION:1s}
      fhir:
        max-attempts: ${RETRY_MAX_ATTEMPTS:3}
        wait-duration: ${RETRY_WAIT_DURATION:1s}
  ratelimiter:
    instances:
      api:
        limit-for-period: ${RATE_LIMIT:1000}
        limit-refresh-period: ${RATE_LIMIT_PERIOD:1m}
        timeout-duration: ${RATE_LIMIT_TIMEOUT:0s}

# Session Management
session:
  timeout: ${SESSION_TIMEOUT:3600}
  redis:
    namespace: ${REDIS_SESSION_NAMESPACE:identity:sessions}
    flush-mode: ${REDIS_FLUSH_MODE:on_save}
    cleanup-cron: ${SESSION_CLEANUP_CRON:0 */5 * * * *}